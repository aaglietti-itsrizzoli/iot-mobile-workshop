<html>

<head>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <style>
        h2 {
            display: inline;
        }

        .container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .team-column {
            flex: 1;
            margin: 0 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .device-button {
            display: block;
            margin: 5px 0;
            padding: 5px;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }

        .turn-controls {
            margin: 20px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <button onclick="startListen()">START LISTEN</button>
    <h2 id="devicesCount"></h2>
    <h2 id="lastDeviceOn"></h2>

    <div class="turn-controls">
        <input type="text" id="turnName" placeholder="Nome del turno">
        <button onclick="createTurn()">Crea Nuovo Turno</button>
        <button onclick="closeTurn()" id="closeTurnButton" disabled>Chiudi Turno Attivo</button>
        <div id="activeTurnInfo" style="margin-top: 10px;">
            <h3>Turno Attivo: <span id="activeTurnName">Nessun turno attivo</span></h3>
            <p>Dispositivi nel turno: <span id="activeTurnDevices">0</span></p>
        </div>
    </div>

    <div class="container">
        <div class="team-column" style="border-color: blue;">
            <h3 style="color: blue;">Team Blue (<span id="blue">0</span>)</h3>
            <div class="water-info" style="margin: 10px 0;">
                <h4>Acqua Risparmiata: <span id="blue-water">0.00</span> L</h4>
            </div>
            <div id="blue-devices"></div>
        </div>
        <div class="team-column" style="border-color: red;">
            <h3 style="color: red;">Team Red (<span id="red">0</span>)</h3>
            <div class="water-info" style="margin: 10px 0;">
                <h4>Acqua Risparmiata: <span id="red-water">0.00</span> L</h4>
            </div>
            <div id="red-devices"></div>
        </div>
        <div class="team-column" style="border-color: #cccc00;">
            <h3 style="color: #cccc00;">Team Yellow (<span id="yellow">0</span>)</h3>
            <div class="water-info" style="margin: 10px 0;">
                <h4>Acqua Risparmiata: <span id="yellow-water">0.00</span> L</h4>
            </div>
            <div id="yellow-devices"></div>
        </div>
        <div class="team-column" style="border-color: green;">
            <h3 style="color: green;">Team Green (<span id="green">0</span>)</h3>
            <div class="water-info" style="margin: 10px 0;">
                <h4>Acqua Risparmiata: <span id="green-water">0.00</span> L</h4>
            </div>
            <div id="green-devices"></div>
        </div>
    </div>
    <br />
    <script>
        var teamIndex = [
            'blue',
            'red',
            'yellow',
            'green',
        ];

        var socket = new WebSocket("wss://" + window.location.hostname + "/echo");
        var devices = [];
        var turnsDevices = new Map(); // Map per tenere traccia dei dispositivi nel turno attivo
        var teams = {
            blue: [],
            red: [],
            yellow: [],
            green: [],
        }
        var activeTurn = null; // Stato del turno attivo

        // Funzione per aggiornare i waterLevel dei team
        function updateTeamWaterLevels() {
            const teamWaterLevels = {
                blue: 0,
                red: 0,
                yellow: 0,
                green: 0
            };

            // Calcola il totale di acqua risparmiata per team
            for (const [deviceId, turnDevice] of turnsDevices.entries()) {
                const device = devices.find(d => d.fingerprint === deviceId);
                if (device && device.team) {
                    const waterSaved = 1 - (turnDevice.waterLevel || 0);
                    teamWaterLevels[device.team] += waterSaved;
                }
            }

            // Aggiorna i display
            for (const team in teamWaterLevels) {
                document.getElementById(`${team}-water`).textContent =
                    teamWaterLevels[team].toFixed(2);
            }
        }

        // Funzione per aggiornare le informazioni del turno attivo
        async function updateActiveTurnInfo() {
            try {
                const response = await fetch('/polling');
                const data = await response.json();
                
                if (data.turn) {
                    activeTurn = data.turn;
                    document.getElementById('activeTurnName').textContent = data.turn.name;
                    document.getElementById('activeTurnDevices').textContent = data.fingerprints.length;
                    document.getElementById('closeTurnButton').disabled = false;
                    
                    // Aggiorna lo stato dei pulsanti dei device
                    updateDeviceButtons(data.fingerprints);
                } else {
                    activeTurn = null;
                    document.getElementById('activeTurnName').textContent = 'Nessun turno attivo';
                    document.getElementById('activeTurnDevices').textContent = '0';
                    document.getElementById('closeTurnButton').disabled = true;
                    
                    // Riabilita tutti i pulsanti
                    updateDeviceButtons([]);
                }
            } catch (error) {
                console.error('Error updating active turn info:', error);
            }
        }

        // Funzione per aggiornare lo stato dei pulsanti dei device
        function updateDeviceButtons(activeFingerprints) {
            document.querySelectorAll('.device-button').forEach(button => {
                const fingerprint = button.getAttribute('data-fingerprint');
                if (activeFingerprints.includes(fingerprint)) {
                    button.disabled = true;
                    button.style.opacity = '0.5';
                } else {
                    button.disabled = false;
                    button.style.opacity = '1';
                }
            });
        }

        socket.onopen = function () {
            console.log("onopen", { _: new Date(), readyState: socket.readyState });
        }

        socket.onmessage = function (msg) {
            console.log("onmessage", { _: new Date(), msg });

            var message = JSON.parse(msg.data);
            console.log("message", { _: new Date(), message });

            switch (message.type) {
                case 'devices':
                    console.log('received device from server');
                    var device = message.data;
                    const existingDeviceIndex = devices.findIndex(d => d.fingerprint === device.fingerprint);
                    if (existingDeviceIndex === -1) {
                        devices.push(device);
                        document.getElementById('devicesCount').innerHTML = devices.length;
                        document.getElementById('lastDeviceOn').innerHTML = new Date().toISOString();
                        var team = device.team;
                        var fingerprint = device.fingerprint;
                        if (teams[team].indexOf(fingerprint) === -1) {
                            teams[team].push(fingerprint);
                            document.getElementById(team).innerHTML = teams[team].length;
                            updateDevicesList(team, fingerprint);
                        }
                    }
                    break;
                    
                case 'turnsDevices':
                    console.log('received turnsDevices update from server');
                    var turnDevice = message.data;
                    
                    // Aggiorna la mappa dei dispositivi nel turno
                    if (turnDevice.waterLevel !== undefined) {
                        turnsDevices.set(turnDevice.deviceId, turnDevice);
                        // Aggiorna i waterLevel visualizzati
                        updateTeamWaterLevels();
                    }
                    
                    // Aggiorna le informazioni del turno attivo
                    updateActiveTurnInfo();
                    break;
            }
        }

        socket.onclose = function () {
            console.log("onclose", { _: new Date(), readyState: socket.readyState });
        }

        function startListen() {
            socket.send('hello world');
            // Avvia l'aggiornamento periodico delle informazioni del turno
            setInterval(updateActiveTurnInfo, 5000);
        }
        
        // Inizializza le informazioni del turno attivo all'avvio
        updateActiveTurnInfo();

        // Funzione per creare un nuovo turno
        async function createTurn() {
            const turnName = document.getElementById('turnName').value;
            if (!turnName) {
                alert('Inserisci un nome per il turno');
                return;
            }

            try {
                const response = await fetch('/turns', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ name: turnName })
                });
                const data = await response.json();
                activeTurn = { id: data.id, name: turnName };
                document.getElementById('turnName').value = '';
                await updateActiveTurnInfo();
            } catch (error) {
                console.error('Error creating turn:', error);
                alert('Errore nella creazione del turno');
            }
        }

        // Funzione per chiudere il turno attivo
        async function closeTurn() {
            if (!activeTurn) {
                alert('Nessun turno attivo');
                return;
            }

            try {
                await fetch(`/turns/${activeTurn.id}`, {
                    method: 'PATCH'
                });
                // Reset stato turno
                activeTurn = null;
                await updateActiveTurnInfo();
                
                // Reset dei waterLevel
                turnsDevices.clear();
                updateTeamWaterLevels();
            } catch (error) {
                console.error('Error closing turn:', error);
                alert('Errore nella chiusura del turno');
            }
        }

        // Funzione per aggiungere un device al turno
        async function addDeviceToTurn(fingerprint) {
            if (!activeTurn) {
                alert('Nessun turno attivo. Crea prima un nuovo turno.');
                return;
            }

            try {
                await fetch(`/turns/${activeTurn.id}/devices/${fingerprint}`, {
                    method: 'POST'
                });
                await updateActiveTurnInfo();
            } catch (error) {
                console.error('Error adding device to turn:', error);
                alert('Errore nell\'aggiunta del device al turno');
            }
        }

        // Funzione per aggiornare la visualizzazione dei devices
        function updateDevicesList(team, fingerprint) {
            const container = document.getElementById(`${team}-devices`);
            if (!container.querySelector(`[data-fingerprint="${fingerprint}"]`)) {
                const button = document.createElement('button');
                button.className = 'device-button';
                button.setAttribute('data-fingerprint', fingerprint);
                button.textContent = fingerprint.slice(0, 6);
                button.onclick = () => addDeviceToTurn(fingerprint);
                button.style.color = team;
                container.appendChild(button);
            }
        }
    </script>
</body>

</html>